[toc]  

# 一、基础概念
## 1、操作系统
[UNIX发展史(BSD,GNU,linux)](https://www.cnblogs.com/Dodge/articles/4264833.html)
### (1)、Windows
### (2)、Mac OS
>苹果系统是基于Unix的。
### (3)、Linux
>安卓系统是基于Linux的，
### (4)、Unix
(1)商业派:以AT&T公司为代表，不公开源码，视源代码为商业机密，甚至不准大学使用Unix源代码。  
(2)BSD:伯克利软件套件”（Berkeley Software Distribution），是加州大学伯克利分校开发的。BSD拥护软件开源，鼓励代码共享。当然，在BSD版本上开发商业版也是允许的，比如苹果的操作系统也是基于BSD UNIX，但苹果的系统是闭源的。
## 2、编译器
&emsp;&emsp;负责“翻译”或“解释”代码的一个软件,把源代码转换成（翻译）低级语言的程序，一个现代编译器的主要工作流程：源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables)。简单来说就是编译器负责将高级语言，如C、C++、Golang等等这些高级语言转换成汇编语言，然后汇编器和链接器负责将汇编语言变为机器可识别的二进制文件，如exe。
>&emsp;&emsp;使用C/C++之类的编译性语言编写的程序，是需要用编译器从源文件转换成计算机使用的机器语言，经过链接器链接之后形成了二进制的可执行文件。但是对于Python而言，python源码不需要编译成二进制代码，它可以直接从源代码运行程序。当我们运行python文件程序的时候，python解释器将源代码转换为字节码，然后再由python解释器来执行这些字节码。这样，python就不用担心程序的编译,库的链接加载等问题了。
**编译器主要的构成分为三部分：**
>&emsp;&emsp;前端 -- AST -- 后端
&emsp;&emsp;前端用于源码解析，最终生成表示源码逻辑的抽象语法树（Abstract Syntax Tree，AST），后端主要将抽象表示的中间代码转为最后适用平台的机器码。
## 3、集成开发环境(IDE)
&emsp;&emsp;我们实际学习和开发过程中大家听到或见过的基本都是IDE（集成开发环境），比如VC6.0、VS、CodeBlocks等等，他们的核心还是编译器，只不过为了大家方便，全部免去命令形式的操作，取而代之的友好的界面，一键编译等方便的操作，还额外提供包括代码高亮、代码调试、项目管理等高级功能。
# 二、GNU(gnu's not unix)

## 1、[GNU](http://www.gnu.org/)
&emsp;&emsp;GNU计划，是由理查德·斯托曼(Richard Stallma)在1983年9月27日公开发起的。GNU工程创始于一九八四年，旨在开发一个完整 GNU 系统。GNU是“GNU's Not Unix”的递归缩写。GNU由一系列应用程序、系统库和开发工具构成的软件集合 , 并加上用于资源分配和硬件管理的内核。GNU自己的内核Hurd仍在开发中，离实用还有一定的距离，不过测试版本已经发布。
&emsp;&emsp;理查德的目标是创建一套完全自由的操作系统，GNU软件可以自由地“使用、复制、修改和发布”。为保证GNU软件可以自由地“使用、复制、修改和发布”，所有GNU软件都包含一份在禁止其他人添加任何限制的情况下，授权所有权利给任何人的协议条款，GNU通用公共许可证(GNU General Public License，GPL)。这个就是被称为‘公共版权’的概念。
## 2、GNU/Linux
&emsp;&emsp;1991年linus torvalds编写出了与unix兼容的linux操作系统内核并在gpl条款下发布。linux之后在网上广泛流传，许多程序员参与了开发与修改。1992年linux与其他gnu软件结合，完全自由的操作系统正式诞生。(尽管如此gnu计划自己的内核hurd依然在开发中，目前已经发布beta版本)
&emsp;&emsp;因此，现在的GNU通常使用Linux内核。这样的组合即为GNU/Linux操作系统。也就是我们常说的Linux系统。
&emsp;&emsp;许多unix系统上也安装了gnu软件，因为gnu软件的质量比之前unix的软件还要好。gnu工具还被广泛地移植到windows和mac os上。
# 三、处理器架构
&emsp;&emsp;处理器就是一堆数字电路（架构）以高低电平的各种组合实现了各种基本的运算（指令）。中央处理单元(CPU)主要由运算器、控制器、寄存器三部分组成。CPU有着处理指令、执行操作、控制时间、处理数据四大作用。CPU架构是CPU厂商给属于同一系列的CPU产品定的一个规范，主要目的是为了区分不同类型CPU的重要标示。
&emsp;&emsp;目前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU，另一个是以IBM、ARM为首的精简指令集CPU。两个不同品牌的CPU，其产品的架构也不相同，例如，Intel、AMD的CPU是X86架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构。

## 1、指令集(从逻辑角度分类)
&emsp;&emsp;计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。每款CPU在设计时就规定了一系列与其硬件电路相配合的指令系统。指令的强弱也是CPU的重要指标，指令集是提高微处理器效率的最有效的工具之一。从现阶段的主流体系结构讲，指令集可分为复杂指令集和精简指令集两部分。
### (1)CISC (Complex Instruction SetComputer, 复杂指令集计算机)
&emsp;&emsp;复杂指令集是一种微处理器指令集架构，每个指令可执行若干低阶操作，诸如从内存读取、储存、和计算操作，全部集于单一指令之中。
>特点：
1.指令系统庞大，指令功能复杂，指令格式、寻址方式多；
2.绝大多数指令需多个机器周期完成；
3.各种指令都可访问存储器；
4.采用微程序控制；
5.有专用寄存器，少量；
6.难以用优化编译技术生成高效的目标代码程序；

&emsp;&emsp;**常见CISC微指令集主要集中在：AMD、Intel、VIA等IA-32、X86架构的CPU产品**
&emsp;&emsp;在CISC指令集的各种指令中，大约有20%的指令会被反复使用，占整个程序代码的80%。而余下的80%的指令却不经常使用，在程序设计中只占20%。
### (2)RISC(Reduced Instruction SetComputer, 精简指令集计算机)
&emsp;&emsp;精简指令集这种设计思路对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。它能够以更快的速度执行操作。
&emsp;&emsp;这种设计思路最早的产生缘自于有人发现，尽管传统处理器设计了许多特性让代码编写更加便捷，但这些复杂特性需要几个指令周期才能实现，并且常常不被运行程序所采用。此外，处理器和主内存之间运行速度的差别也变得越来越大。在这些因素促使下，出现了一系列新技术，使处理器的指令得以流水执行，同时降低处理器访问内存的次数。实际上在后来的发展中，RISC与CISC在竞争的过程中相互学习，现在的RISC指令集也达到数百条，运行周期也不再固定。虽然如此，RISC设计的根本原则——针对流水线化的处理器优化——没有改变，而且还在遵循这种原则的基础上发展出RISC的一个并行化变种VLIW(超长指令集)（包括Intel EPIC(显式并行指令集)），就是将简短而长度统一的精简指令组合出超长指令，每次执行一条超长指令，等于并行执行多条短指令。
>特点：
1.统一指令编码（例如，所有指令中的op-code永远位于同样的位元位置、等长指令），可快速解译；
2.泛用的暂存器，所有暂存器可用于所有内容，以及编译器设计的单纯化（不过暂存器中区分了整数和浮点数）；
3.单纯的寻址模式（复杂寻址模式以简单计算指令序列取代）；
4.硬件中支援少数资料型别（例如，一些CISC电脑中存有处理字节字串的指令。这在RISC电脑中不太可能出现）。

&emsp;&emsp;**常见RISC微指令集主要集中在：DECAlpha、ARC、ARM、AVR、MIPS、PA-RISC、IBM（PowerArchitecture(包括PowerPC)）、SUN（SPARC）**
## 2、架构(x86、ARM、MIPS等常见架构) 
### (1)、X86架构
>应用领域：个人计算机、服务器等

&emsp;&emsp;x86或80x86是英特尔首先开发制造的一种微处理器体系结构的泛称。该系列较早期的处理器名称是以数字来表示，并以“86”作为结尾，包括Intel 8086、80186、80286、80386以及80486，因此其架构被称为“x86”。
&emsp;&emsp;x86架构于1978年推出的Intel 8086中央处理器中首度出现，它是从Intel 8008处理器中发展而来的，而8008则是发展自Intel 4004的。8086在三年后为IBM PC所选用，之后x86便成为了个人电脑的标准平台，成为了历来最成功的CPU架构。 8086是16位元处理器;直到1985年32位元(i386或x86-32)的80386的开发，这个架构都维持是16位元。接着一系列的处理器表示了32位元架构的细微改进，推出了数种的扩充，直到2003年AMD对于这个架构发展了64位元的扩充，并命名为AMD64。后来Intel也推出了与之兼容的处理器，并命名为Intel 64。两者一般被统称为x86-64或x64，开创了x86的64位时代。
&emsp;&emsp;Intel早在1990年代就与惠普合作提出了一种用在安腾系列处理器中的独立的64位架构，这种架构被称为IA-64。IA-64是一种崭新的架构，和x86架构完全没有相似性。
>- X86：这是对于1978年推出的Intel 8086及后续CPU产品的统一称呼
>- IA-32(x86_32,i386)：Intel Architecture-32的缩写，是一种不向下兼容的Intel >-32-bit CPU 架构。在英特尔公司1985年推出的80386微处理器中首先采用。通常也被称为i386、x86-32等。
>- IA-64：Intel Architecture-64的缩写，是一种不向下兼容的Intel 64-bit CPU 架构。IA64是后来1990年代intel和惠普联合推出的64位体系架构，但是不兼容原有的32位体系结构的应用程序，导致市场惨淡。
>- X64(x86_64)：是2003年AMD推出的兼容32位的64位集关于IA-32的扩展，之后改名为AMD64，Intel后来也采用该架构，称为x86-64或者x64

&emsp;&emsp;如今，我们面前的PC机基本都是x86架构计算机。如果你想尝试其他架构的计算机，首先要考虑的是是否放弃Windows系统。
&emsp;&emsp;一般我们查询电脑cpu的位数，如果出现x86，i396，i586则为32位，如果出现AMD64，x64则为64位。
&emsp;&emsp;64 位CPU理论上的数据处理能力更强。64 位 CPU 通用寄存器的位宽增加一倍，可以一次性处理 64bit 的整形数据
&emsp;&emsp;64 位CPU的内存寻址能力更强。32位CPU 地址总线不超过 32，它所能达到的寻址范围，理论上只能使用约 4GB，即不超过2的32次方字节；64 位 CPU，理论上寻址范围可以达到上亿 GB（2 的 64 次方字节）
### (2)、ARM架构(32位)
>应用领域：手机、PAD、导航系统、网络设备等都是ARM架构，目前世界上使用最广泛的CPU就是ARM。

&emsp;&emsp;ARM架构：精简指令集机器RISC（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM成立1991年英国剑桥，主要出售芯片设计技术授权。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列。
### (3)、MIPS架构
>应用领域：工作站等计算机平台，目前国内龙芯主要使用MIPS架构机器

&emsp;&emsp;MIPS架构(英语：MIP Sarchitecture，为“无内部互锁流水级的微处理器Microprocessor without Interlocked Pipeline Stages的缩写，也是Millionsof Instructions Per Second的相关语)，是一种采取精简指令集(RISC)的处理器架构，1981年出现，由MIPS科技公司开发并授权，广泛被使用在许多电子产品、网络设备、个人娱乐装置与商业装置上。其机制是尽量利用软件办法避免流水线中的数据相关问题。它最早是在80年代初期由斯坦福(Stanford)大学Hennessy教授领导的研究小组研制出来的。MIPS公司的R系列就是在此基础上开发的RISC工业产品的微处理器。这些系列产品为很多计算机公司采用构成各种工作站和计算机系统。
&emsp;&emsp;MIPS是出现最早的商业RISC架构芯片之一。MIPS的系统结构及设计理念比较先进，强调软硬件协同提高性能，同时简化硬件设计。
&emsp;&emsp;2002年，中国科学院计算所开始研发龙芯处理器，采用MIPS架构，但未经MIPS公司的授权，遭到侵权的控告。2007年，中国科学院与MIPS公司达成和解，得到正式授权。中国龙芯2和前代产品采用的都是64位MIPS指令架构。过去，MIPS架构的产品多见于工作站领域，索尼PS2游戏机所用的“Emotion Engine”也采用MIPS指令，这些MIPS处理器的性能都非常强劲，而龙芯2也属于这个阵营，在软件方面与上述产品完全兼容。
### (3)、PowerPC架构
&emsp;&emsp;PowerPC 是一种精简指令集（RISC）架构的中央处理器（CPU），其基本的设计源自IBM（国际商用机器公司）的IBM PowerPC 601 微处理器POWER（Performance Optimized With Enhanced RISC；《IBM Connect 电子报》2007年8月号译为“增强RISC性能优化”）架构。二十世纪九十年代，IBM(国际商用机器公司)、Apple（苹果公司）和Motorola（摩托罗拉）公司开发PowerPC芯片成功，并制造出基于PowerPC的多处理器计算机。PowerPC架构的特点是可伸缩性好、方便灵活。PowerPC 处理器有广泛的实现范围，包括从诸如 Power4 那样的高端服务器 CPU 到嵌入式 CPU 市场（任天堂 Gamecube 使用了 PowerPC）。PowerPC 处理器有非常强的嵌入式表现，因为它具有优异的性能、较低的能量损耗以及较低的散热量。除了象串行和以太网控制器那样的集成 I/O，该嵌入式处理器与“台式机”CPU 存在非常显著的区别。
# 四、C++编译器(常用的几种)
## 1、MSVC(Microsoft Visual C++ Compiler)
&emsp;&emsp;MSVC是微软Windows平台Visual Studio自带的C/C++编译器，对Windows平台支持好，编译快。
## 2、GCC(GNU Compiler Collection)
&emsp;&emsp;The GNU Compiler Collection，通常简称GCC，是一套由GNU开发的编译器集，为什么是编辑器集而不是编译器呢？那是因为它不仅支持C语言编译，还支持C++, Ada, Objective C等许多语言。另外GCC对硬件平台的支持，可以所无所不在，它不仅支持X86处理器架构, 还支持ARM, Motorola 68000, Motorola 8800, Atmel AVR, MIPS等处理器架构。类Unix下的标准编译器，支持众多语言，支持交叉编译。默认不支持Windows，需要第三方移植才可用于Windows。
## 3、Cygwin
&emsp;&emsp;Cygwin是一个在windows平台上运行的类UNIX模拟环境(模拟不是虚拟)，是cygnus solutions公司开发的**自由软件**。它对于学习UNIX/Linux操作环境，或者从UNIX到Windows的应用程序移植，或者进行某些特殊的开发工作，尤其是使用GNU工具集在Windows上进行嵌入式系统开发非常有用。随着嵌入式系统开发在国内日渐流行，越来越多的开发者对Cygwin产生了兴趣。
## 4、MingW(Minimalist GNU For Windows)
&emsp;&emsp;MinGW是个精简的Windows平台下的 C/C++、ADA及Fortran的**编译环境**，相比Cygwin而言，体积要小很多，使用较为方便。MinGW最大的特点就是编译出来的可执行文件能够独立在Windows上运行。
&emsp;&emsp;MinGW 提供了一套简单方便的**Windows下的基于GCC 程序开发环境**。MinGW 收集了一系列免费的Windows 使用的头文件和库文件；同时整合了GNU 的工具集，特别是GNU程序开发工具，如经典gcc, g++, make等。MinGW是完全免费的自由软件，它在Windows平台上模拟了Linux下GCC的开发环境，为C++的跨平台开发提供了良好基础支持，为了在Windows下工作的程序员熟悉Linux下的C++工程组织提供了条件。
## 5、LLVM(Low Level Virtual Machine )__Clang
&emsp;&emsp; LLVM是一个开源的编译器架构，Clang是LLVM的一个编译器前端。由于优秀的设计，使得clang非常适合用于开发源代码级别的分析工具。  
&emsp;&emsp;由于GNU编译器套装(GCC)系统庞大，而且Apple大量使用的 Objective-C在GCC中优先级较低，同时GCC作为一个纯粹的编译系统，与IDE配合并不优秀，Apple决定从零开始写C family的前端，也就是基于LLVM的Clang了。  
&emsp;&emsp;clang是LLVM编译器工具集的一个用于编译C、C++、Objective-C的前端。LLVM项目的目标是提供一个GNU编译器套装（gcc）的替代品，由苹果公司的赞助开发，其源代码授权采用的是类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。  
&emsp;&emsp;LLVM本身并不是编译器，而是一种编译器的基础架构，在编译器构成部分中，作为一个基础后端，进行机器码的生成处理。clang并不是编译器，clang是LLVM编译架构的编译前端而已，仅仅是LLVM众多项目中的一个。而整个的编译过程最终都要LLVM的编译基础架构将生成的中间码转成机器码。